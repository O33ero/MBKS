#### Вопрос 21

##### Реализация моделей безопасности КС. Модели на основе дискреционного разграничения доступа. Модель Харрисона-Руззо-Ульмана(ХРУ). Анализ безопасности систем ХРУ. Алгоритмическая проверка безопасности монооперационной системы ХРУ.

*Определение 2.2.* Будем считать, что в состоянии $q$ системы ХРУ возможна утечка права доступа $r \in R$ в результате выполнения команды $с(x_1, \dots ,x_k)$ в случае, когда при переходе системы $q \vdash _{c(x_1, \dots, x_k)} q'$ выполняется примитивный оператор, вносящий право доступа $r$ в ячейку матрицы доступов $M$, до этого $r$ не содержавшую.

*Определение 2.3.* Начальное состояние $q_0$ системы ХРУ называется безопасным относительно некоторого права доступа $r \in R$ в случае, когда невозможен переход системы в такое состояние $q$, в котором возможна утечка права $r$. Иными словами, начальное состояние $q_0$ системы ХРУ называется безопасным относительно некоторого права доступа $r$, когда невозможен переход системы в состояние, в котором право доступа $r$ появилось в ячейке матрицы доступов $M$, до этого $r$ не содержавшей.

*Определение 2.4.* Система ХРУ называется монооперационной, когда каждая команда системы содержит один примитивный оператор.

*Теорема 2.1.* Существует алгоритм, проверяющий является ли начальное состояние произвольной монооперационной системы ХРУ безопасным относительно некоторого права доступа $r \in R$.

*Доказательство.* Для доказательства достаточно показать, что является конечной максимальная длина последовательности команд монооперационной системы, каждая из которых вносит новые права доступа в матрицу доступов. В этом случае алгоритм проверки безопасности будет заключаться в применении к начальному состоянию данной последовательности команд и в проверке конечного состояния на отсутствие утечки права доступа $r$.

Заметим, что нет необходимости строить последовательность с командами, содержащими примитивные операторы вида «удалить»$\dots$ и «уничтожить»$\dots$, так как в условиях команд при реализации утечки проверяется наличие прав доступа, а не их отсутствие. 



**Возможны три случая.**

**Первый случай:** в начальном состоянии системы $q_0 = (S_0, O_0, M_0)$ выполняются следующие условия:

- множество субъектов $S_0 \neq \varnothing$;
- существуют $(s,o) \in S_0 \times O_0$ такие, что $r \notin M_0[s,o].$ 

Тогда нет необходимости включать в последовательность команды, содержащие примитивный оператор вида «создать».... Это обусловлено тем, что все последовательности команд, которые вносят права доступа в новые ячейки матрицы доступов, могут быть заменой параметров в командах представлены последовательностями, которые действуют с существующими субъектами и объектами. Число различных примитивных операторов вида «внести»...

$$ n = |R| |S_0| |O_0|.$$

В каждой команде возможна проверка не более п различных условий на наличие в некоторой ячейке матрицы доступов некоторого права доступа. Следовательно, максимальное число различных команд, содержащих примитивный оператор вида «внести»..., с различными наборами параметров не превосходит $n2^n$.

Алгоритм построения последовательности команд, позволяющей для первого случая проверить возможность утечки права доступа $r$, состоит из выполнения следующих шагов.

Шаг 1. Проверить выполнение условий первого случая.

Шаг 2. Построить список $L$ всех команд, содержащих примитивный оператор вида «внести»... с различными наборами параметров $(|L| \leqslant n2^n).$ 

Шаг 3. Перейти к началу списка $L.$

Шаг 4. Если список $L$ пройден или пуст, то утечка права доступа $r$ невозможна. В этом случае закончить выполнение алгоритма. Иначе выбрать из списка $L$ очередную команду. Если условие команды выполнено, то перейти на шаг 5, иначе перейти на шаг 4.

Шаг 5. Удалить выбранную на шаге 4 команду из списка $L$ и применить ее. Если в результате этого произошла утечка права доступа $r$, то закончить выполнение алгоритма. Иначе перейти на шаг 3.

Данный алгоритм выполняется за конечное число шагов, в результате чего, начиная с начального состояния системы, реализуется конечная последовательность команд, позволяющая в первом случае проверить возможность утечки права доступа $r$.

**Второй случай:** в начальном состоянии системы $q_0 = (S_0, O_0, М_0) $выполняется условие $S_0 = \varnothing $. Тогда необходимо применить одну команду, содержащую примитивный оператор вида «создать» субъект, и перейти к первому случаю.

Алгоритм построения последовательности команд, позволяющей для второго случая проверить возможность утечки права доступа $r$ состоит из выполнения следующих шагов. 

Шаг 1. Проверить выполнение условий второго случая.

Шаг 2. Рассмотреть все команды системы (их конечное число), содержащие примитивный оператор вида «создать» субъект. Если все такие команды содержат проверку условий, то их применение невозможно, следовательно, невозможна утечка права доступа $r$. В этом случае закончить выполнение алгоритма. Если существует команда без условий, содержащая примитивный оператор вида «создать» субъект, то применить ее.

Шаг 3. Выполнить алгоритм, построенный для первого случая. При этом справедливо равенство $n = |R|(|O_0| + 1).$

Данный алгоритм выполняется за конечное число шагов, в результате чего, начиная с начального состояния системы, реализуется конечная последовательность команд, позволяющая во втором случае проверить возможность утечки права доступа $r$.

**Третий случай:** в начальном состоянии системы $q_0 = (S_0, O_0,M_0)$ выполняются следующие условия:

- множество субъектов $S_0 \neq \varnothing$;

- для всех $(s,o) \in S_0 \times O_0$ выполняется условие $r \in M_0[s,o]. $

Так как нет необходимости включать в последовательность более одной команды, содержащей примитивный оператор вида «создать»... следует на основе алгоритма для первого случая с использованием команд, содержащих примитивный оператор вида «внести»..., обеспечить (если это возможно) применение одной команды, содержащей примитивный оператор вида «создать»..., после чего перейти первому случаю. Заметим, что максимальное число различных команд, содержащих примитивный оператор вида «создать»... («создать» субъект или «создать» объект), с различными наборами параметров не превосходит $2 \cdot 2^m$, где $ m = |R| |S_0| |О_0|.$

Алгоритм построения последовательности команд, позволяющей для третьего случая проверить возможность утечки права доступа $r$, состоит из выполнения следующих шагов.

Шаг 1. Проверить выполнение условий третьего случая.

Шаг 2. Построить список $L_1$ всех команд системы, содержащих примитивный оператор вида «внести»... с различными наборами параметров $(|L_1| \leqslant m \cdot 2^m)$. Построить список $L_2$ всех команд системы, содержащих примитивный оператор вида «создать»..., с различными наборами параметров $(|L_2| \leqslant 2^{m+1}).$

Шаг 3. Перейти к началу списка $L_1$.

Шаг 4. Если список $L_1$ пройден или пуст, то утечка права доступа $r$ невозможна. В этом случае закончить выполнение алгоритма. Иначе выбрать из списка $L_1$ очередную команду. Если условие команды выполнено, то перейти на шаг 5, иначе перейти на шаг 4.

Шаг 5. Удалить выбранную на шаге 4 команду из списка $L_1$ и применить ее. Последовательно по списку $L_2$ проверить возможность применения хотя бы одной команды, содержащей примитивный оператор вида «создать».... Если такая команда найдена, то применить ее и перейти на шаг 6. Иначе перейти на шаг 3.

Шаг 6. Выполнить алгоритм, построенный для первого случая. При этом выполняются условия:

- если на шаге 5 применена команда, содержащая примитивный оператор вида «создать» субъект, то выполняется равенство $$ n = |R| (|S_0| + 1)(|O_0|+1);$$

- если на шаге 5 применена команда, содержащая примитивный оператор вида «создать» объект, то выполняется равенство $$ n = |R||S_0|(|O_0|+1)$$.

Таким образом, для каждого из трех случаев описаны алгоритмы, позволяющие за конечное число шагов построить последовательность команд конечной длины. В результате применения последовательности, начиная с начального состояния, система переходит в состояние, которое назовем конечным. Если в конечном состоянии произошла утечка права доступа $r$, то начальное состояние системы не является безопасным относительно права доступа $r$, в противном случае начальное состояние системы является безопасным относительно права доступа $r$.

Теорема доказана.

*Следствие 2.1.* Алгоритм проверки безопасности монооперационных систем имеет экспоненциальную сложность.

*Теорема 2.2.* Задача проверки безопасности произвольных систем ХРУ алгоритмически неразрешима.